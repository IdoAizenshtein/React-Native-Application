package com.reactcamera;import android.os.Build;import android.annotation.SuppressLint;import android.app.Activity;import android.content.Context;import android.graphics.Rect;import android.view.LayoutInflater;import android.widget.FrameLayout;import android.hardware.display.DisplayManager;import android.view.MotionEvent;import androidx.camera.core.FocusMeteringResult;import com.facebook.react.bridge.Callback;import com.facebook.react.bridge.WritableMap;import com.facebook.react.bridge.WritableNativeMap;import com.facebook.react.bridge.ReactContext;import com.facebook.react.uimanager.events.RCTEventEmitter;import android.view.OrientationEventListener;import androidx.camera.core.FocusMeteringAction;import java.util.concurrent.TimeUnit;import android.media.Image;import android.graphics.BitmapFactory;import android.view.Surface;import android.os.Bundle;import android.Manifest;import android.content.pm.PackageManager;import android.net.Uri;import android.util.Log;import android.widget.Toast;import androidx.core.app.ActivityCompat;import androidx.core.content.ContextCompat;import java.io.FileNotFoundException;import java.io.IOException;import java.util.concurrent.Executors;import androidx.camera.core.*;import androidx.camera.lifecycle.ProcessCameraProvider;import java.io.File;import java.nio.ByteBuffer;import java.text.SimpleDateFormat;import java.util.*;import java.util.concurrent.ExecutorService; import com.biziboxapp.R;import androidx.annotation.NonNull;import androidx.camera.core.Camera;import androidx.camera.core.CameraSelector;import androidx.camera.core.ImageAnalysis;import androidx.camera.core.ImageCapture;import androidx.camera.core.ImageCaptureException;import androidx.camera.core.Preview;// import androidx.camera.extensions.HdrImageCaptureExtender;import androidx.camera.lifecycle.ProcessCameraProvider;import androidx.camera.view.PreviewView;import androidx.core.app.ActivityCompat;import androidx.core.content.ContextCompat;import androidx.lifecycle.LifecycleOwner;import java.io.FileOutputStream;import android.content.pm.PackageManager;import android.os.Bundle;import android.os.Environment;import android.os.Handler;import android.os.Looper;import android.util.Log;import android.view.View;import android.widget.ImageView;import android.widget.Toast;import android.widget.Button;import android.graphics.Bitmap;import android.graphics.Matrix;import android.util.DisplayMetrics;import com.google.common.util.concurrent.ListenableFuture;import java.io.OutputStream;import java.io.File;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Locale;import java.util.concurrent.ExecutionException;import java.util.concurrent.Executor;import java.util.concurrent.Executors;import com.facebook.react.uimanager.ThemedReactContext;import androidx.appcompat.app.AppCompatActivity;import android.view.Choreographer;import android.util.Size;import android.view.Display;import java.lang.Math;//import android.util.Rational;import com.facebook.react.bridge.ReactApplicationContext;public class MainView extends FrameLayout {    private static final String TAG = "MainView";    public static MainView instance = null;    ThemedReactContext mContext;    private ExecutorService executor = Executors.newSingleThreadExecutor();    private int REQUEST_CODE_PERMISSIONS = 1001;    private ArrayList<String> arrlist = new ArrayList<String>();    private String[] REQUIRED_PERMISSIONS;    private final double RATIO_4_3_VALUE = 4.0 / 3.0;    private final double RATIO_16_9_VALUE = 16.0 / 9.0;//    private static final Rational PREVIEW_ASPECT_RATIO_4_X_3 = new Rational(4, 3);    PreviewView mPreviewView;    Button captureImage;    ProcessCameraProvider cameraProvider;    MeteringPoint pointFocused = null;    //    int rotationDegrees = 0;    public static MainView getInstance() {        return instance;    }    public static void createInstance(ThemedReactContext context, Activity activity) {        instance = new MainView(context, activity);    }    @Override    public void onDetachedFromWindow() {        super.onDetachedFromWindow();        executor.shutdown();    }    private MainView(ThemedReactContext context, Activity activity) {        super(context);        Log.d("ReactSpoCameraManager", "--------------uifyytdhgjfgjhfdythfyug875674674674674446746747----");        mContext = context;        arrlist.add("android.permission.CAMERA");        if (Build.VERSION.SDK_INT <= 28) {            arrlist.add("android.permission.WRITE_EXTERNAL_STORAGE");        }        REQUIRED_PERMISSIONS = new String[arrlist.size()];        for (int j = 0; j < arrlist.size(); j++) {            REQUIRED_PERMISSIONS[j] = arrlist.get(j);        }        FrameLayout layout = (FrameLayout) LayoutInflater.from(context).inflate(R.layout.activity_main, this, true);        mPreviewView = layout.findViewById(R.id.viewFinder);//        captureImage = findViewById(R.id.camera_capture_button);        Log.d("allPermissionsGranted()", "" + allPermissionsGranted());        if (allPermissionsGranted()) {            if (cameraProvider == null) {                startCamera();                setupLayoutHack();            } else {                setupLayoutHack();                bindPreview(cameraProvider);            }        } else {            ActivityCompat.requestPermissions(mContext.getCurrentActivity(), REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS);        }    }    public void startCamera() {        Log.d(TAG, "startCamera");        final ListenableFuture<ProcessCameraProvider> cameraProviderFuture = ProcessCameraProvider.getInstance(mContext);        cameraProviderFuture.addListener(new Runnable() {            @Override            public void run() {                try {                    cameraProvider = cameraProviderFuture.get();                    bindPreview(cameraProvider);                } catch (ExecutionException | InterruptedException e) {                    // No errors need to be handled for this Future.                    // This should never be reached.                }            }        }, ContextCompat.getMainExecutor(mContext));    }    private int aspectRatio(int width, int height) {        double s1 = Double.parseDouble(String.valueOf(Math.max(width, height)));        int previewRatio = (int) (s1 / Math.min(width, height));        if (Math.abs(previewRatio - RATIO_4_3_VALUE) <= Math.abs(previewRatio - RATIO_16_9_VALUE)) {            return AspectRatio.RATIO_4_3;        }        return AspectRatio.RATIO_16_9;    }    public void bindPreview(@NonNull ProcessCameraProvider cameraProvider) {        Log.d(TAG, "bindPreview");//        int screenAspectRatio;//        // Get screen metrics used to setup camera for full screen resolution//        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {//            Rect metrics = mContext.getCurrentActivity().getWindowManager().getCurrentWindowMetrics().getBounds();//            Log.d(TAG, "Screen metrics: ${metrics.width()} x ${metrics.height()}");//            screenAspectRatio = aspectRatio(metrics.width(), metrics.height());//        } else {//            DisplayMetrics displayMetrics = new DisplayMetrics();//            mContext.getCurrentActivity().getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);//            Log.d(TAG, "Screen metrics: ${displayMetrics.widthPixels} x ${displayMetrics.heightPixels}");//            screenAspectRatio = aspectRatio(displayMetrics.widthPixels, displayMetrics.heightPixels);//        }//        Log.d(TAG, "screenAspectRatios: ${screenAspectRatio}");        mPreviewView.setImplementationMode(PreviewView.ImplementationMode.PERFORMANCE);        Preview preview = new Preview.Builder()//                .setTargetResolution(new Size(1080, 1920))//                .setTargetAspectRatio(screenAspectRatio)//                .setTargetRotation(mContext.getCurrentActivity().getDisplay().getRotation())                .build();        CameraSelector cameraSelector = new CameraSelector.Builder()                .requireLensFacing(CameraSelector.LENS_FACING_BACK).build();        ImageAnalysis imageAnalysis = new ImageAnalysis.Builder()//                .setTargetAspectRatio(screenAspectRatio)//                .setTargetRotation(mContext.getCurrentActivity().getDisplay().getRotation())                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)                .build();        ImageCapture.Builder builder = new ImageCapture.Builder();//        HdrImageCaptureExtender hdrImageCaptureExtender = HdrImageCaptureExtender.create(builder);////        if (hdrImageCaptureExtender.isExtensionAvailable(cameraSelector)) {//            hdrImageCaptureExtender.enableExtension(cameraSelector);//        }//      .setCaptureMode(ImageCapture.CAPTURE_MODE_MAXIMIZE_QUALITY)        final ImageCapture imageCapture = builder//                .setTargetResolution(new Size(1080, 1920))                .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)//                .setTargetAspectRatio(screenAspectRatio)//                .setTargetRotation(mContext.getCurrentActivity().getDisplay().getRotation())                .build();        preview.setSurfaceProvider(mPreviewView.getSurfaceProvider());//        Camera camera = cameraProvider.bindToLifecycle((AppCompatActivity) mContext.getCurrentActivity(), cameraSelector, preview, imageAnalysis);//        Camera camera = cameraProvider.bindToLifecycle((AppCompatActivity) mContext.getCurrentActivity(), cameraSelector, preview, imageAnalysis, imageCapture);        try {            cameraProvider.unbindAll();            Camera camera = cameraProvider.bindToLifecycle((LifecycleOwner) mContext.getCurrentActivity(), cameraSelector, preview, imageCapture, imageAnalysis);//            CameraControl cameraControl = camera.getCameraControl();//            mPreviewView.setOnTouchListener(new OnTouchListener() {//                @SuppressLint("ClickableViewAccessibility")//                @Override//                public boolean onTouch(View v, MotionEvent event) {//                    if (event.getAction() != MotionEvent.ACTION_UP) {//                        return true;//                    }//                    Log.d(TAG, "ClickableViewAccessibility");//                    // Get the MeteringPointFactory from PreviewView//                    MeteringPointFactory factory = mPreviewView.getMeteringPointFactory();//                    // Create a MeteringPoint from the tap coordinates//                    MeteringPoint point = factory.createPoint(event.getX(), event.getY());//                    pointFocused = point;//                    // Create a MeteringAction from the MeteringPoint, you can configure it to specify the metering mode//                    FocusMeteringAction action = new FocusMeteringAction.Builder(point, FocusMeteringAction.FLAG_AF)//                            .build();//                    // Trigger the focus and metering. The method returns a ListenableFuture since the operation//                    // is asynchronous. You can use it get notified when the focus is successful or if it fails.//                    cameraControl.startFocusAndMetering(action);//                    return true;//                }//            });//            cameraControl.cancelFocusAndMetering();        } catch (Exception exc) {            Log.e(TAG, "Use case binding failed", exc);        }//        setOnClickListenerButton(imageCapture);//        imageAnalysis.setAnalyzer(executor, new ImageAnalysis.Analyzer() {//            @Override//            public void analyze(@NonNull ImageProxy image) {//                rotationDegrees = image.getImageInfo().getRotationDegrees();//                // insert your code here.//                Log.d(TAG, "rotationDegrees: " + rotationDegrees);//            }//        });        WritableMap cameraReadyConfig = new WritableNativeMap();        cameraReadyConfig.putBoolean("cameraReady", true);        onCameraReady(cameraReadyConfig);    }//    public void setOnClickListenerButton(ImageCapture imageCapture) {//        captureImage.setOnClickListener(v -> {//            Log.d(TAG, "setOnClickListener");////            rotationDegrees = 0;////            SimpleDateFormat mDateFormat = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US);////            File file = new File(getBatchDirectoryName(), mDateFormat.format(new Date()) + ".jpg");////            ImageCapture.OutputFileOptions outputFileOptions = new ImageCapture.OutputFileOptions.Builder(file).build();//            imageCapture.takePicture(executor, new ImageCapture.OnImageCapturedCallback() {//                @Override//                public void onCaptureSuccess(@NonNull ImageProxy image) {//                    int height = image.getHeight();//                    int width = image.getWidth();//                    Log.d(TAG, String.valueOf(height));//                    Log.d(TAG, String.valueOf(width));//                    Log.d(TAG, "image:   ------------ " + String.valueOf(image));////                    int rotationDegrees = image.getImageInfo().getRotationDegrees();//                    Log.d(TAG, "rotationDegrees:   ------------ " + String.valueOf(rotationDegrees));////                    SimpleDateFormat mDateFormat = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US);//                    File file = new File(getBatchDirectoryName(), mDateFormat.format(new Date()) + ".jpg");////                    ByteBuffer buffer = image.getPlanes()[0].getBuffer();//                    buffer.rewind();//                    byte[] bytes = new byte[buffer.capacity()];//                    buffer.get(bytes);//                    byte[] clonedBytes = bytes.clone();//                    Bitmap pictureBitmapSecond = BitmapFactory.decodeByteArray(clonedBytes, 0, clonedBytes.length);//                    int heightLast = pictureBitmapSecond.getHeight();//                    int widthLast = pictureBitmapSecond.getWidth();//                    if (rotationDegrees != 0) {//                        Matrix matrix = new Matrix();//                        matrix.preRotate(rotationDegrees);//                        Bitmap finalBitmap = Bitmap.createBitmap(pictureBitmapSecond, 0, 0, widthLast, heightLast, matrix, true);//                        OutputStream fOut = null;//                        try {//                            fOut = new FileOutputStream(file);//                        } catch (FileNotFoundException e) {//                            e.printStackTrace();//                        }//                        finalBitmap.compress(Bitmap.CompressFormat.JPEG, 100, fOut);//                        try {//                            fOut.flush(); // Not really required//                        } catch (IOException e) {//                            e.printStackTrace();//                        }//                        try {//                            fOut.close(); // do not forget to close the stream//                        } catch (IOException e) {//                            e.printStackTrace();//                        }////                        BitmapFactory.Options bmOptionsLast = new BitmapFactory.Options();//                        bmOptionsLast.inJustDecodeBounds = true;//                        BitmapFactory.decodeFile(file.getAbsolutePath(), bmOptionsLast);//                        widthLast = bmOptionsLast.outWidth;//                        heightLast = bmOptionsLast.outHeight;////                        WritableMap pictureWasTakenConfig = new WritableNativeMap();//                        pictureWasTakenConfig.putInt("width", widthLast);//                        pictureWasTakenConfig.putInt("height", heightLast);//                        pictureWasTakenConfig.putString("uri", "file://" + file.getPath());//                        pictureWasTakenConfig.putString("getAbsolutePath", "" + file.getAbsolutePath());//                        onPictureTaken(pictureWasTakenConfig);//                    } else {////                        @SuppressLint("UnsafeExperimentalUsageError") Image imageData = image.getImage();////                        OutputStream fOut = null;//                        try {//                            fOut = new FileOutputStream(file);//                        } catch (FileNotFoundException e) {//                            e.printStackTrace();//                        }//                        pictureBitmapSecond.compress(Bitmap.CompressFormat.JPEG, 100, fOut);//                        try {//                            fOut.flush(); // Not really required//                        } catch (IOException e) {//                            e.printStackTrace();//                        }//                        try {//                            fOut.close(); // do not forget to close the stream//                        } catch (IOException e) {//                            e.printStackTrace();//                        }////                        WritableMap pictureWasTakenConfig = new WritableNativeMap();//                        pictureWasTakenConfig.putInt("width", widthLast);//                        pictureWasTakenConfig.putInt("height", heightLast);//                        pictureWasTakenConfig.putString("uri", "file://" + file.getPath());//                        pictureWasTakenConfig.putString("getAbsolutePath", "" + file.getAbsolutePath());//                        onPictureTaken(pictureWasTakenConfig);//                    }//////                    image.close();//                }////                @Override//                public void onError(@NonNull final ImageCaptureException exception) {//                    Log.d(TAG, "error" + exception);//                    exception.printStackTrace();//                }//            });//////            imageCapture.takePicture(outputFileOptions, executor, new ImageCapture.OnImageSavedCallback() {////                @Override////                public void onImageSaved(@NonNull ImageCapture.OutputFileResults outputFileResults) {////                    new Handler(Looper.getMainLooper()).post(new Runnable() {////                        @Override////                        public void run() {////                            Log.d(TAG, "outputFileResults------------------" + file.getPath());////                            Log.d(TAG, "getRotation------------------" + rotationDegrees);////////                            WritableMap pictureWasTakenConfig = new WritableNativeMap();////////                            if (file.exists()) {////                                BitmapFactory.Options bmOptions = new BitmapFactory.Options();////                                bmOptions.inJustDecodeBounds = true;////                                BitmapFactory.decodeFile(file.getAbsolutePath(), bmOptions);////                                int photoW = bmOptions.outWidth;////                                int photoH = bmOptions.outHeight;////////                                BitmapFactory.Options bmOptionsSecond = new BitmapFactory.Options();////                                bmOptionsSecond.inJustDecodeBounds = false;////                                Bitmap pictureBitmapSecond = BitmapFactory.decodeFile(file.getAbsolutePath(), bmOptionsSecond);////////                                if (rotationDegrees != 0) {////                                    Matrix matrix = new Matrix();////                                    matrix.preRotate(rotationDegrees);////                                    Bitmap finalBitmap = Bitmap.createBitmap(pictureBitmapSecond, 0, 0, photoW, photoH, matrix, true);////                                    OutputStream fOut = null;////                                    try {////                                        fOut = new FileOutputStream(file);////                                    } catch (FileNotFoundException e) {////                                        e.printStackTrace();////                                    }////                                    finalBitmap.compress(Bitmap.CompressFormat.JPEG, 100, fOut);////                                    try {////                                        fOut.flush(); // Not really required////                                    } catch (IOException e) {////                                        e.printStackTrace();////                                    }////                                    try {////                                        fOut.close(); // do not forget to close the stream////                                    } catch (IOException e) {////                                        e.printStackTrace();////                                    }////                                    BitmapFactory.Options bmOptionsLast = new BitmapFactory.Options();////                                    bmOptionsLast.inJustDecodeBounds = true;////                                    BitmapFactory.decodeFile(file.getAbsolutePath(), bmOptionsLast);////                                    photoW = bmOptionsLast.outWidth;////                                    photoH = bmOptionsLast.outHeight;////                                }////////////                                pictureWasTakenConfig.putInt("width", photoW);////                                pictureWasTakenConfig.putInt("height", photoH);////                                pictureWasTakenConfig.putString("uri", "file://" + file.getPath());////                                pictureWasTakenConfig.putString("getAbsolutePath", "" + file.getAbsolutePath());////                                onPictureTaken(pictureWasTakenConfig);////                            }////                        }////                    });////                }////////                @Override////                public void onError(@NonNull ImageCaptureException error) {////                    Log.d(TAG, "error" + error);////////                    error.printStackTrace();////                }////            });//        });//    }    void setupLayoutHack() {        Choreographer.getInstance().postFrameCallback(new Choreographer.FrameCallback() {            @Override            public void doFrame(long frameTimeNanos) {//                Log.d(TAG, "setupLayoutHack");                manuallyLayoutChildren();                getViewTreeObserver().dispatchOnGlobalLayout();                Choreographer.getInstance().postFrameCallback(this);            }        });    }    void manuallyLayoutChildren() {        for (int i = 0; i < getChildCount(); i++) {            View child = getChildAt(i);            child.measure(MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),                    MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));            child.layout(0, 0, child.getMeasuredWidth(), child.getMeasuredHeight());        }    }    public void takePicture(Callback errorCallback, Callback successCallback) {//        captureImage.performClick();//        int screenAspectRatio;//        // Get screen metrics used to setup camera for full screen resolution//        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {//            Rect metrics = mContext.getCurrentActivity().getWindowManager().getCurrentWindowMetrics().getBounds();//            Log.d(TAG, "Screen metrics: ${metrics.width()} x ${metrics.height()}");//            screenAspectRatio = aspectRatio(metrics.width(), metrics.height());//        } else {//            DisplayMetrics displayMetrics = new DisplayMetrics();//            mContext.getCurrentActivity().getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);//            Log.d(TAG, "Screen metrics: ${displayMetrics.widthPixels} x ${displayMetrics.heightPixels}");//            screenAspectRatio = aspectRatio(displayMetrics.widthPixels, displayMetrics.heightPixels);//        }//        Log.d(TAG, "screenAspectRatios: ${screenAspectRatio}");        new Handler(Looper.getMainLooper()).post(new Runnable() {            @Override            public void run() {                try {                    mPreviewView.setImplementationMode(PreviewView.ImplementationMode.PERFORMANCE);                    Preview preview = new Preview.Builder()//                            .setTargetResolution(new Size(1080, 1920))//                            .setTargetAspectRatio(screenAspectRatio)//                            .setTargetRotation(mContext.getCurrentActivity().getDisplay().getRotation())                            .build();                    CameraSelector cameraSelector = new CameraSelector.Builder()                            .requireLensFacing(CameraSelector.LENS_FACING_BACK)                            .build();                    ImageAnalysis imageAnalysis = new ImageAnalysis.Builder()//                            .setTargetAspectRatio(screenAspectRatio)//                            .setTargetRotation(mContext.getCurrentActivity().getDisplay().getRotation())                            .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)                            .build();                    ImageCapture.Builder builder = new ImageCapture.Builder();//                    HdrImageCaptureExtender hdrImageCaptureExtender = HdrImageCaptureExtender.create(builder);////                    if (hdrImageCaptureExtender.isExtensionAvailable(cameraSelector)) {//                        hdrImageCaptureExtender.enableExtension(cameraSelector);//                    }                    final ImageCapture imageCapture = builder//                            .setTargetResolution(new Size(1080, 1920))//                            .setTargetAspectRatio(screenAspectRatio)//                            .setTargetRotation(mContext.getCurrentActivity().getDisplay().getRotation())                            .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)                            .build();//                    OrientationEventListener orientationEventListener = new OrientationEventListener((ThemedReactContext) mContext) {//                        @Override//                        public void onOrientationChanged(int orientation) {//                            int rotation;////                            // Monitors orientation values to determine the target rotation value//                            if (orientation >= 45 && orientation < 135) {//                                rotation = Surface.ROTATION_270;//                            } else if (orientation >= 135 && orientation < 225) {//                                rotation = Surface.ROTATION_180;//                            } else if (orientation >= 225 && orientation < 315) {//                                rotation = Surface.ROTATION_90;//                            } else {//                                rotation = Surface.ROTATION_0;//                            }////                            Log.d(TAG, "orientation:   ------------  " + orientation);////                            imageCapture.setTargetRotation(rotation);//                        }//                    };////                    orientationEventListener.enable();                    preview.setSurfaceProvider(mPreviewView.getSurfaceProvider());                    cameraProvider.unbindAll();                    Camera camera = cameraProvider.bindToLifecycle((LifecycleOwner) mContext.getCurrentActivity(), cameraSelector, preview, imageCapture, imageAnalysis);//                    CameraControl cameraControl = camera.getCameraControl();//                    if (pointFocused != null) {//                        Log.d(TAG, "got pointFocused");////                        // Create a MeteringAction from the MeteringPoint, you can configure it to specify the metering mode//                         FocusMeteringAction action = new FocusMeteringAction.Builder(pointFocused, FocusMeteringAction.FLAG_AF)//                                 .setAutoCancelDuration(1, TimeUnit.NANOSECONDS)//                                 .build();//                         // Trigger the focus and metering. The method returns a ListenableFuture since the operation//                         // is asynchronous. You can use it get notified when the focus is successful or if it fails.//                         cameraControl.startFocusAndMetering(action);//                     } else {//                         cameraControl.cancelFocusAndMetering();//                     }//                    cameraControl.cancelFocusAndMetering();//                    cameraControl.cancelFocusAndMetering();//                    MeteringPointFactory factory = new SurfaceOrientedMeteringPointFactory(1f, 1f);//                    MeteringPoint point = factory.createPoint(.5f, .5f);//                    FocusMeteringAction action = new FocusMeteringAction.Builder(point, FocusMeteringAction.FLAG_AF)//                            .setAutoCancelDuration(200, TimeUnit.MILLISECONDS)//                            .build();////                    ListenableFuture future = cameraControl.startFocusAndMetering(action);//                    future.addListener(() -> {//                        try {////                            FocusMeteringResult result = (FocusMeteringResult) future.get();//                            // process the result//                        } catch (Exception e) {//                        }//                    }, executor);//                    final ImageCapture imageCapture = new ImageCapture.Builder()//                            .setCaptureMode(ImageCapture.CAPTURE_MODE_MAXIMIZE_QUALITY)//                            .build();                    WritableMap pictureWasTakenConfig = new WritableNativeMap();                    Log.d(TAG, "image:   ------------  takePicture");                    imageCapture.takePicture(executor, new ImageCapture.OnImageCapturedCallback() {                        @Override                        public void onCaptureSuccess(@NonNull ImageProxy image) {                            int height = image.getHeight();                            int width = image.getWidth();                            Log.d(TAG, String.valueOf(height));                            Log.d(TAG, String.valueOf(width));                            Log.d(TAG, "image:   ------------ " + String.valueOf(image));                            int rotationDegrees = image.getImageInfo().getRotationDegrees();                            Log.d(TAG, "rotationDegrees:   ------------ " + String.valueOf(rotationDegrees));                            SimpleDateFormat mDateFormat = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US);                            File file = new File(getBatchDirectoryName(), mDateFormat.format(new Date()) + ".jpg");                            ByteBuffer buffer = image.getPlanes()[0].getBuffer();                            buffer.rewind();                            byte[] bytes = new byte[buffer.capacity()];                            buffer.get(bytes);                            byte[] clonedBytes = bytes.clone();                            Bitmap pictureBitmapSecond = BitmapFactory.decodeByteArray(clonedBytes, 0, clonedBytes.length);                            int heightLast = pictureBitmapSecond.getHeight();                            int widthLast = pictureBitmapSecond.getWidth();                            if (rotationDegrees != 0) {                                double aspectRatio;                                int targetWidth = widthLast;                                int targetHeight = heightLast;                                if (heightLast >= widthLast) {                                    targetHeight = mPreviewView.getHeight();                                    if (heightLast <= targetHeight) { // if image already smaller than the required height                                    } else {                                        aspectRatio = (double) widthLast / (double) heightLast;                                        targetWidth = (int) (targetHeight * aspectRatio);                                    }                                } else {                                    targetWidth = mPreviewView.getWidth();                                    if (widthLast <= targetWidth) { // if image already smaller than the required height                                    } else {                                        aspectRatio = ((double) heightLast) / ((double) widthLast);                                        targetHeight = (int) (targetWidth * aspectRatio);                                    }                                }                                if (((targetWidth * 2) < widthLast) && ((targetHeight * 2) < heightLast)) {                                    targetWidth = (int) (targetWidth * 2);                                    targetHeight = (int) (targetHeight * 2);                                }                                Bitmap result = Bitmap.createScaledBitmap(pictureBitmapSecond, targetWidth, targetHeight, false);                                pictureBitmapSecond.recycle();                                Matrix matrix = new Matrix();                                matrix.preRotate(rotationDegrees);                                Bitmap finalBitmap = Bitmap.createBitmap(result, 0, 0, targetWidth, targetHeight, matrix, true);                                result.recycle();                                OutputStream fOut = null;                                try {                                    fOut = new FileOutputStream(file);                                } catch (FileNotFoundException e) {                                    e.printStackTrace();                                }                                finalBitmap.compress(Bitmap.CompressFormat.JPEG, 100, fOut);                                finalBitmap.recycle();                                try {                                    fOut.flush(); // Not really required                                } catch (IOException e) {                                    e.printStackTrace();                                }                                try {                                    fOut.close(); // do not forget to close the stream                                } catch (IOException e) {                                    e.printStackTrace();                                }                                BitmapFactory.Options bmOptionsLast = new BitmapFactory.Options();                                bmOptionsLast.inJustDecodeBounds = true;                                BitmapFactory.decodeFile(file.getAbsolutePath(), bmOptionsLast);                                widthLast = bmOptionsLast.outWidth;                                heightLast = bmOptionsLast.outHeight;                                //                    onPictureTaken(pictureWasTakenConfig);                            } else {//                        @SuppressLint("UnsafeExperimentalUsageError") Image imageData = image.getImage();                                OutputStream fOut = null;                                try {                                    fOut = new FileOutputStream(file);                                } catch (FileNotFoundException e) {                                    e.printStackTrace();                                }                                pictureBitmapSecond.compress(Bitmap.CompressFormat.JPEG, 100, fOut);                                pictureBitmapSecond.recycle();                                try {                                    fOut.flush(); // Not really required                                } catch (IOException e) {                                    e.printStackTrace();                                }                                try {                                    fOut.close(); // do not forget to close the stream                                } catch (IOException e) {                                    e.printStackTrace();                                }                            }                            pictureWasTakenConfig.putInt("width", widthLast);                            pictureWasTakenConfig.putInt("height", heightLast);                            pictureWasTakenConfig.putString("uri", "file://" + file.getPath());                            pictureWasTakenConfig.putString("getAbsolutePath", "" + file.getAbsolutePath());                            image.close();                            successCallback.invoke(pictureWasTakenConfig);                        }                        @Override                        public void onError(@NonNull final ImageCaptureException exception) {                            Log.d(TAG, "error" + exception);                            exception.printStackTrace();                        }                    });//                                SimpleDateFormat mDateFormat = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US);//                                File file = new File(getBatchDirectoryName(), mDateFormat.format(new Date()) + ".jpg");//                                ImageCapture.OutputFileOptions outputFileOptions = new ImageCapture.OutputFileOptions.Builder(file).build();//                                imageCapture.takePicture(outputFileOptions, executor, new ImageCapture.OnImageSavedCallback() {//                                    @Override//                                    public void onImageSaved(@NonNull ImageCapture.OutputFileResults outputFileResults) {//                                        new Handler(Looper.getMainLooper()).post(new Runnable() {//                                            @Override//                                            public void run() {//                                                Log.d(TAG, "outputFileResults------------------" + file.getPath());////                            Log.d(TAG, "getRotation------------------" + rotationDegrees);//                                                int rotationDegrees = 90;//                                                WritableMap pictureWasTakenConfig = new WritableNativeMap();////                                                if (file.exists()) {//                                                    BitmapFactory.Options bmOptions = new BitmapFactory.Options();//                                                    bmOptions.inJustDecodeBounds = true;//                                                    BitmapFactory.decodeFile(file.getAbsolutePath(), bmOptions);//                                                    int widthLast = bmOptions.outWidth;//                                                    int heightLast = bmOptions.outHeight;//                                                    Log.d(TAG, String.valueOf(widthLast));//                                                    Log.d(TAG, String.valueOf(heightLast));////                                                    BitmapFactory.Options bmOptionsFirst = new BitmapFactory.Options();//                                                    bmOptionsFirst.inJustDecodeBounds = false;//                                                    Bitmap pictureBitmapSecond = BitmapFactory.decodeFile(file.getAbsolutePath(), bmOptionsFirst);////                                                    if (rotationDegrees != 0) {//                                                        double aspectRatio;//                                                        int targetWidth = widthLast;//                                                        int targetHeight = heightLast;//                                                        if (heightLast >= widthLast) {//                                                            targetHeight = mPreviewView.getHeight();//                                                            if (heightLast <= targetHeight) { // if image already smaller than the required height////                                                            } else {//                                                                aspectRatio = (double) widthLast / (double) heightLast;//                                                                targetWidth = (int) (targetHeight * aspectRatio);//                                                            }//                                                        } else {//                                                            targetWidth = mPreviewView.getWidth();//                                                            if (widthLast <= targetWidth) { // if image already smaller than the required height//                                                            } else {//                                                                aspectRatio = ((double) heightLast) / ((double) widthLast);//                                                                targetHeight = (int) (targetWidth * aspectRatio);//                                                            }//                                                        }//                                                        targetWidth = targetWidth * 2;//                                                        targetHeight = targetHeight * 2;//                                                        Bitmap result = Bitmap.createScaledBitmap(pictureBitmapSecond, targetWidth, targetHeight, false);//                                                        pictureBitmapSecond.recycle();////                                                        Matrix matrix = new Matrix();//                                                        matrix.preRotate(rotationDegrees);//                                                        Bitmap finalBitmap = Bitmap.createBitmap(result, 0, 0, targetWidth, targetHeight, matrix, true);//                                                        result.recycle();////                                                        OutputStream fOut = null;//                                                        try {//                                                            fOut = new FileOutputStream(file);//                                                        } catch (FileNotFoundException e) {//                                                            e.printStackTrace();//                                                        }//                                                        finalBitmap.compress(Bitmap.CompressFormat.JPEG, 100, fOut);//                                                        finalBitmap.recycle();//                                                        try {//                                                            fOut.flush(); // Not really required//                                                        } catch (IOException e) {//                                                            e.printStackTrace();//                                                        }//                                                        try {//                                                            fOut.close(); // do not forget to close the stream//                                                        } catch (IOException e) {//                                                            e.printStackTrace();//                                                        }////                                                        BitmapFactory.Options bmOptionsLast = new BitmapFactory.Options();//                                                        bmOptionsLast.inJustDecodeBounds = true;//                                                        BitmapFactory.decodeFile(file.getAbsolutePath(), bmOptionsLast);//                                                        widthLast = bmOptionsLast.outWidth;//                                                        heightLast = bmOptionsLast.outHeight;////                                                        //                    onPictureTaken(pictureWasTakenConfig);//                                                    } else {////                        @SuppressLint("UnsafeExperimentalUsageError") Image imageData = image.getImage();////                                                        OutputStream fOut = null;//                                                        try {//                                                            fOut = new FileOutputStream(file);//                                                        } catch (FileNotFoundException e) {//                                                            e.printStackTrace();//                                                        }//                                                        pictureBitmapSecond.compress(Bitmap.CompressFormat.JPEG, 100, fOut);//                                                        pictureBitmapSecond.recycle();//                                                        try {//                                                            fOut.flush(); // Not really required//                                                        } catch (IOException e) {//                                                            e.printStackTrace();//                                                        }//                                                        try {//                                                            fOut.close(); // do not forget to close the stream//                                                        } catch (IOException e) {//                                                            e.printStackTrace();//                                                        }////                                                    }//////                                BitmapFactory.Options bmOptionsSecond = new BitmapFactory.Options();////                                bmOptionsSecond.inJustDecodeBounds = false;////                                Bitmap pictureBitmapSecond = BitmapFactory.decodeFile(file.getAbsolutePath(), bmOptionsSecond);//////                                if (rotationDegrees != 0) {////                                    Matrix matrix = new Matrix();////                                    matrix.preRotate(rotationDegrees);////                                    Bitmap finalBitmap = Bitmap.createBitmap(pictureBitmapSecond, 0, 0, photoW, photoH, matrix, true);////                                    OutputStream fOut = null;////                                    try {////                                        fOut = new FileOutputStream(file);////                                    } catch (FileNotFoundException e) {////                                        e.printStackTrace();////                                    }////                                    finalBitmap.compress(Bitmap.CompressFormat.JPEG, 100, fOut);////                                    try {////                                        fOut.flush(); // Not really required////                                    } catch (IOException e) {////                                        e.printStackTrace();////                                    }////                                    try {////                                        fOut.close(); // do not forget to close the stream////                                    } catch (IOException e) {////                                        e.printStackTrace();////                                    }////                                    BitmapFactory.Options bmOptionsLast = new BitmapFactory.Options();////                                    bmOptionsLast.inJustDecodeBounds = true;////                                    BitmapFactory.decodeFile(file.getAbsolutePath(), bmOptionsLast);////                                    photoW = bmOptionsLast.outWidth;////                                    photoH = bmOptionsLast.outHeight;////                                }////////                                pictureWasTakenConfig.putInt("width", mPreviewView.getWidth());////                                pictureWasTakenConfig.putInt("height", mPreviewView.getHeight());//                                                    pictureWasTakenConfig.putInt("width", widthLast);//                                                    pictureWasTakenConfig.putInt("height", heightLast);//                                                    pictureWasTakenConfig.putString("uri", "file://" + file.getPath());//                                                    pictureWasTakenConfig.putString("getAbsolutePath", "" + file.getAbsolutePath());////                                onPictureTaken(pictureWasTakenConfig);//                                                    successCallback.invoke(pictureWasTakenConfig);//                                                }//                                            }//                                        });//                                    }////                                    @Override//                                    public void onError(@NonNull ImageCaptureException error) {//                                        Log.d(TAG, "error" + error);////                                        error.printStackTrace();//                                        errorCallback.invoke(error.getMessage());//                                    }//                                });                } catch (Exception exc) {                    // No errors need to be handled for this Future.                    // This should never be reached.                    errorCallback.invoke(exc.getMessage());                }            }        });    }    public void onPictureTaken(WritableMap config) {        Log.d(TAG, "onPictureTaken");        final ReactContext context = (ReactContext) getContext();        context.getJSModule(RCTEventEmitter.class).receiveEvent(getId(), "onPictureTaken", config);    }    public void onCameraReady(WritableMap config) {        Log.d(TAG, "onCameraReady");        final ReactContext context = (ReactContext) getContext();        context.getJSModule(RCTEventEmitter.class).receiveEvent(getId(), "onCameraReady", config);    }    public String getBatchDirectoryName() {        String app_folder_path = "";        app_folder_path = mContext.getExternalFilesDir(null).getAbsolutePath() + "/images";        File dir = new File(app_folder_path);        if (!dir.exists() && !dir.mkdirs()) {            dir.mkdir();        }//        if (!dir.exists()) {//            dir.mkdir();//        }//        Log.i("app_folder_path", app_folder_path);        return app_folder_path;    }    private boolean allPermissionsGranted() {        for (String permission : REQUIRED_PERMISSIONS) {            if (ContextCompat.checkSelfPermission(mContext, permission) != PackageManager.PERMISSION_GRANTED) {                return false;            }        }        return true;    }}